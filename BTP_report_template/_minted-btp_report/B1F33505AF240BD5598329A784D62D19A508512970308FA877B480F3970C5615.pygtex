\begin{Verbatim}[commandchars=\\\{\}]
  \PYG{k+kr}{datatype} \PYG{k+kt}{stm} \PYG{p}{=} \PYG{n+nc}{SEQ} \PYG{k+kr}{of} \PYG{n}{stm} \PYG{n}{*} \PYG{n}{stm} \PYG{c+cm}{(* The statement s2 followed by s2. *)}
  \PYG{p}{|} \PYG{n+nc}{LABEL} \PYG{k+kr}{of} \PYG{n}{label} \PYG{c+cm}{(* Define the constant value of name n to be the current machine code address. This is like a label definition in assembly language. *)}
  \PYG{p}{|} \PYG{n+nc}{JUMP} \PYG{k+kr}{of} \PYG{n}{exp} \PYG{n}{*} \PYG{n}{label} \PYG{n}{list} \PYG{c+cm}{(* Transfer control (jump) to address exp. The destination exp may be a literal label, as in NAME(lab), or it may be an address calculated by any other kind of expression. For example, a C\PYGZhy{}language switch (i) statement may be implemented by doing arithmetic on i. The list of labels labs specifies all the possible locations that the expression exp can evaluate to; this is necessary for dataflow analysis later. The common case of jumping to a known label \PYGZdq{}l\PYGZdq{} is written as jump(name l, [l]). *)}
  \PYG{p}{|} \PYG{n+nc}{CJUMP} \PYG{k+kr}{of} \PYG{n}{relop} \PYG{n}{*} \PYG{n}{exp} \PYG{n}{*} \PYG{n}{exp} \PYG{n}{*} \PYG{n}{label} \PYG{n}{*} \PYG{n}{label} \PYG{c+cm}{(* CJUMP(o, e1, e2, t, f): Evaluate e1, e2 in that order, yielding values a, b. Then compare a, b using the relational operator o. If the result is true, jump to t otherwise jump to f. The relational operators *)}
  \PYG{p}{|} \PYG{n+nc}{MOVE} \PYG{k+kr}{of} \PYG{n}{exp} \PYG{n}{*} \PYG{n}{exp}
  \PYG{c+cm}{(*}
\PYG{c+cm}{     MOVE(TEMP t, e): Evaluate e and move it into temporary t.}
\PYG{c+cm}{     MOVE(MEM(e1), e2) Evaluate e1 yielding address a. Then evaluate e2 and store the result into wordSize bytes of memory starting at a.}
\PYG{c+cm}{  *)}
  \PYG{p}{|} \PYG{n+nc}{EXP} \PYG{k+kr}{of} \PYG{n}{exp} \PYG{c+cm}{(* Evaluate exp and discard the result. *)}

\PYG{k+kr}{and} \PYG{k+kt}{exp} \PYG{p}{=} \PYG{n+nc}{BINOP} \PYG{k+kr}{of} \PYG{n}{binop} \PYG{n}{*} \PYG{n}{exp} \PYG{n}{*} \PYG{n}{exp} \PYG{c+cm}{(* The application of binary operators to operands exp1, exp2. *)}
  \PYG{p}{|} \PYG{n+nc}{MEM} \PYG{k+kr}{of} \PYG{n}{exp} \PYG{c+cm}{(* The contents of wordSize bytes of memory starting at address exp (where wordSize is defined in the Frame module). Note that when MEM is used as the left child of a move, it means \PYGZdq{}store,\PYGZdq{} but anywhere else it means \PYGZdq{}fetch.\PYGZdq{} *)}
  \PYG{p}{|} \PYG{n+nc}{TEMP} \PYG{k+kr}{of} \PYG{n+nn}{Temp}\PYG{p}{.}\PYG{n}{temp} \PYG{c+cm}{(* Temporary t. A temporary in the abstract machine is similar to a register in a real machine. However, the abstract machine has an infinite number of temporaries. *)}
  \PYG{p}{|} \PYG{n+nc}{ESEQ} \PYG{k+kr}{of} \PYG{n}{stm} \PYG{n}{*} \PYG{n}{exp} \PYG{c+cm}{(* The statement s is evaluated for side effects, then e is evaluated for result *)}
  \PYG{p}{|} \PYG{n+nc}{NAME} \PYG{k+kr}{of} \PYG{n}{label} \PYG{c+cm}{(* The value NAME(n) may be the target of jumps, calls, etc. *)}
  \PYG{p}{|} \PYG{n+nc}{CONST} \PYG{k+kr}{of} \PYG{n}{int} \PYG{c+cm}{(* The integer constant int. *)}
  \PYG{p}{|} \PYG{n+nc}{CALL} \PYG{k+kr}{of} \PYG{n}{exp} \PYG{n}{*} \PYG{n}{exp} \PYG{n}{list} \PYG{c+cm}{(* A procedure call: the application of function exp1 to argument list exp2 list. The subexpression exp1 is evaluated before the arguments which are evaluated left to right. *)}

\PYG{k+kr}{and} \PYG{k+kt}{binop} \PYG{p}{=} \PYG{n+nc}{PLUS} \PYG{p}{|} \PYG{n+nc}{MINUS} \PYG{p}{|} \PYG{n+nc}{MUL} \PYG{p}{|} \PYG{n+nc}{DIV} \PYG{p}{|} \PYG{n+nc}{AND} \PYG{p}{|} \PYG{n+nc}{OR} \PYG{p}{|} \PYG{n+nc}{LSHIFT} \PYG{p}{|} \PYG{n+nc}{RSHIFT} \PYG{p}{|} \PYG{n+nc}{ARSHIFT} \PYG{p}{|} \PYG{n+nc}{XOR}

\PYG{k+kr}{and} \PYG{k+kt}{relop} \PYG{p}{=} \PYG{n+nc}{EQ} \PYG{p}{|} \PYG{n+nc}{NE} \PYG{p}{|} \PYG{n+nc}{LT} \PYG{p}{|} \PYG{n+nc}{GT} \PYG{p}{|} \PYG{n+nc}{LE} \PYG{p}{|} \PYG{n+nc}{GE} \PYG{p}{|} \PYG{n+nc}{ULT} \PYG{p}{|} \PYG{n+nc}{ULE} \PYG{p}{|} \PYG{n+nc}{UGT} \PYG{p}{|} \PYG{n+nc}{UGE}
\end{Verbatim}
