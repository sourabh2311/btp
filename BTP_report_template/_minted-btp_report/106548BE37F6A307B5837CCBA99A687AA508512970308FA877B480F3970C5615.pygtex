\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kr}{structure} \PYG{n+nn}{RiscFrame}\PYG{p}{:} \PYG{n}{FRAME} \PYG{p}{=} \PYG{k+kr}{struct}

\PYG{k+kr}{structure} \PYG{n+nn}{T} \PYG{p}{=} \PYG{n}{Temp}
\PYG{k+kr}{structure} \PYG{n+nn}{Tr} \PYG{p}{=} \PYG{n}{Tree}


\PYG{c+cm}{(* in register or in frame? i.e. whether are we putting it in register or in stack? *)}
\PYG{k+kr}{datatype} \PYG{k+kt}{access} \PYG{p}{=} \PYG{n+nc}{InFrame} \PYG{k+kr}{of} \PYG{n}{int} \PYG{p}{|} \PYG{n+nc}{InReg} \PYG{k+kr}{of} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{temp}

\PYG{c+cm}{(* numLocals: How many variables got called by allocLocal which were put in our stack (i.e. not in register but in Frame) *)}
\PYG{c+cm}{(* name: Name of the frame (function), access list: tells for each formal parameter whether it is in Frame or in reg. *)}
\PYG{k+kr}{type} \PYG{k+kt}{frame} \PYG{p}{=} \PYG{p}{\PYGZob{}}\PYG{n}{name} \PYG{p}{:} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{label}\PYG{p}{,} \PYG{n}{formals} \PYG{p}{:} \PYG{n}{access} \PYG{n}{list}\PYG{p}{,} \PYG{n}{numLocals} \PYG{p}{:} \PYG{n}{int} \PYG{n}{ref}\PYG{p}{,} \PYG{n}{shiftInstr} \PYG{p}{:} \PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{stm} \PYG{n}{list}\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{type} \PYG{k+kt}{register} \PYG{p}{=} \PYG{n}{string}  \PYG{c+cm}{(* so type of our register list will be \PYGZdq{}string list\PYGZdq{}, register list is useful to tell available registers *)}

\PYG{c+cm}{(*}
\PYG{c+cm}{  Given a Tiger function definition comprising a level and an already\PYGZhy{}translated body expression, the Translate phase should produce a descriptor for the function containing this necessary information:}
\PYG{c+cm}{    1. frame: The frame descriptor containing machine\PYGZhy{}specific information about local variables and parameters.}
\PYG{c+cm}{    2. body: The result returned from procEntryExit1 (defined in detail below). Call this pair a fragment to be translated to assembly language.}
\PYG{c+cm}{*)}
\PYG{c+cm}{(* A string literal in the Tiger (or C) language is the constant address of a segment of memory initialized to the proper characters. *)}
\PYG{c+cm}{(* For each string literal \PYGZdq{}lit\PYGZdq{}, the Translate module makes a new label \PYGZdq{}lab\PYGZdq{}, and returns the tree \PYGZdq{}Tree.name (lab)\PYGZdq{}. It also puts the  assembly\PYGZhy{}language fragment \PYGZdq{}Frame.STRING (lab, lit)\PYGZdq{}\PYGZdq{} onto a global list of such fragments to be handed to the code emitter. *)}
\PYG{c+cm}{(* All this would be handled in putting it all together phase (chapter 12 i.e. in main.sml) *)}
\PYG{k+kr}{datatype} \PYG{k+kt}{frag} \PYG{p}{=} \PYG{n+nc}{PROC} \PYG{k+kr}{of} \PYG{p}{\PYGZob{}}\PYG{n}{body}\PYG{p}{:} \PYG{n+nn}{Tree}\PYG{p}{.}\PYG{n}{stm}\PYG{p}{,} \PYG{n}{frame}\PYG{p}{:} \PYG{n}{frame}\PYG{p}{\PYGZcb{}}
              \PYG{p}{|} \PYG{n+nc}{STRING} \PYG{k+kr}{of} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{label} \PYG{n}{*} \PYG{n}{string}

\PYG{c+cm}{(* \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}CPU Registers\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} *)}

\PYG{k+kr}{val} \PYG{n+nv}{zero} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()} \PYG{c+cm}{(* constant 0 *)}
\PYG{k+kr}{val} \PYG{n+nv}{ra} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()} \PYG{c+cm}{(* return address *)}
\PYG{k+kr}{val} \PYG{n+nv}{sp} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()} \PYG{c+cm}{(* stack pointer *)}

\PYG{c+cm}{(* arguments *)}
\PYG{k+kr}{val} \PYG{n+nv}{a0} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{a1} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{a2} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{a3} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{a4} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{a5} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{a6} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{a7} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}

\PYG{k+kr}{val} \PYG{n+nv}{rv} \PYG{p}{=} \PYG{n}{a0}

\PYG{c+cm}{(* temporary *)}
\PYG{k+kr}{val} \PYG{n+nv}{t0} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{t1} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{t2} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{t3} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{t4} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{t5} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{t6} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}

\PYG{c+cm}{(* saved temporary *)}
\PYG{k+kr}{val} \PYG{n+nv}{s0} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()} \PYG{c+cm}{(* s0 = fp *)}
\PYG{k+kr}{val} \PYG{n+nv}{s1} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{s2} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{s3} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{s4} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{s5} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{s6} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{s7} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{s8} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{s9} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{s10} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}
\PYG{k+kr}{val} \PYG{n+nv}{s11} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{()}

\PYG{k+kr}{val} \PYG{n+nv}{fp} \PYG{p}{=} \PYG{n}{s0}

\PYG{k+kr}{val} \PYG{n+nv}{specialregs} \PYG{p}{=} \PYG{p}{[(}\PYG{n}{zero}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}zero\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{sp}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}sp\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{ra}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}ra\PYGZdq{}}\PYG{p}{)]}

\PYG{k+kr}{val} \PYG{n+nv}{argRegs} \PYG{p}{=} \PYG{p}{[(}\PYG{n}{a0}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}a0\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{a1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}a1\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{a2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}a2\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{a3}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}a3\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{a4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}a4\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{a5}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}a5\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{a6}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}a6\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{a7}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}a7\PYGZdq{}}\PYG{p}{)]}

\PYG{k+kr}{val} \PYG{n+nv}{savedRegs} \PYG{p}{=} \PYG{p}{[(}\PYG{n}{s0}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}s0\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{s1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}s1\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{s2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}s2\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{s3}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}s3\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{s4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}s4\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{s5}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}s5\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{s6}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}s6\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{s7}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}s7\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{s8}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}s8\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{s9}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}s9\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{s10}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}s10\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{s11}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}s11\PYGZdq{}}\PYG{p}{)]}

\PYG{k+kr}{val} \PYG{n+nv}{temporaries} \PYG{p}{=} \PYG{p}{[(}\PYG{n}{t0}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}t0\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{t1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}t1\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{t2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}t2\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{t3}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}t3\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{t4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}t4\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{t5}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}t5\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{t6}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}t6\PYGZdq{}}\PYG{p}{),} \PYG{p}{(}\PYG{n}{t7}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}t7\PYGZdq{}}\PYG{p}{)]}

\PYG{c+cm}{(* Supporting only traditional a0 \PYGZhy{} a7 arguments, i.e. maximum of 8 arguments. *)}
\PYG{k+kr}{exception} \PYG{n+nc}{ArgExceed} \PYG{k+kr}{of} \PYG{n}{string}

\PYG{k+kr}{val} \PYG{n+nv}{wordSize} \PYG{p}{=} \PYG{l+m+mi}{4}

\PYG{c+cm}{(* registers allocated for arguments in risc *)}
\PYG{k+kr}{val} \PYG{n+nv}{argRegsCount} \PYG{p}{=} \PYG{n+nn}{List}\PYG{p}{.}\PYG{n}{length} \PYG{n}{argRegs}

\PYG{k+kr}{fun} \PYG{n+nf}{getFirstL} \PYG{p}{(}\PYG{n}{ls}\PYG{p}{)} \PYG{p}{=} \PYG{p}{(}\PYG{n}{map} \PYG{p}{(}\PYG{k+kr}{fn} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)} \PYG{p}{=\PYGZgt{}} \PYG{n}{x}\PYG{p}{)} \PYG{n}{ls}\PYG{p}{)}
\PYG{k+kr}{fun} \PYG{n+nf}{getSecondL} \PYG{p}{(}\PYG{n}{ls}\PYG{p}{)} \PYG{p}{=} \PYG{p}{(}\PYG{n}{map} \PYG{p}{(}\PYG{k+kr}{fn} \PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)} \PYG{p}{=\PYGZgt{}} \PYG{n}{y}\PYG{p}{)} \PYG{n}{ls}\PYG{p}{)}

\PYG{c+cm}{(* Getting all the registers available for coloring *)}
\PYG{k+kr}{val} \PYG{n+nv}{registers} \PYG{p}{=} \PYG{n}{getSecondL}\PYG{p}{(}\PYG{n}{savedRegs} \PYG{n}{@} \PYG{n}{temporaries}\PYG{p}{)}

\PYG{c+cm}{(* tempMap is a table from registers (not all registers but some) to their name *)}
\PYG{c+cm}{(* basically its use is for new temporaries, so that we can assign register to them as well *)}
\PYG{k+kr}{val} \PYG{n+nv}{tempMap} \PYG{p}{=}
\PYG{k+kr}{let}
  \PYG{k+kr}{fun} \PYG{n+nf}{addToTable} \PYG{p}{((}\PYG{n}{t}\PYG{p}{,} \PYG{n}{s}\PYG{p}{),} \PYG{n}{table}\PYG{p}{)} \PYG{p}{=} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n+nn}{Table}\PYG{p}{.}\PYG{n}{enter}\PYG{p}{(}\PYG{n}{table}\PYG{p}{,} \PYG{n}{t}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}
  \PYG{k+kr}{val} \PYG{n+nv}{toAdd} \PYG{p}{=} \PYG{n}{specialregs} \PYG{n}{@} \PYG{n}{argRegs} \PYG{n}{@} \PYG{n}{savedRegs} \PYG{n}{@} \PYG{n}{temporaries}
\PYG{k+kr}{in}
  \PYG{n}{foldl} \PYG{n}{addToTable} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n+nn}{Table}\PYG{p}{.}\PYG{n}{empty} \PYG{n}{toAdd}
\PYG{k+kr}{end}

\PYG{c+cm}{(* Helper Functions *)}
\PYG{k+kr}{fun} \PYG{n+nf}{incrementNumLocals} \PYG{p}{(\PYGZob{}}\PYG{n}{numLocals}\PYG{p}{,} \PYG{p}{...\PYGZcb{}} \PYG{p}{:} \PYG{n}{frame}\PYG{p}{)} \PYG{p}{=} \PYG{n}{numLocals} \PYG{n}{:=} \PYG{n}{!numLocals} \PYG{n}{+} \PYG{l+m+mi}{1}
\PYG{k+kr}{fun} \PYG{n+nf}{getOffset} \PYG{p}{(\PYGZob{}}\PYG{n}{numLocals}\PYG{p}{,} \PYG{p}{...\PYGZcb{}} \PYG{p}{:} \PYG{n}{frame}\PYG{p}{)} \PYG{p}{=} \PYG{n}{!numLocals} \PYG{n}{*} \PYG{p}{(}\PYG{n}{\PYGZti{}wordSize}\PYG{p}{)}
\PYG{k+kr}{fun} \PYG{n+nf}{getFOffset} \PYG{p}{(}\PYG{n}{frame\PYGZsq{}} \PYG{p}{:} \PYG{n}{frame}\PYG{p}{)} \PYG{p}{=} \PYG{n}{\PYGZti{}}\PYG{p}{(}\PYG{n}{getOffset} \PYG{p}{(}\PYG{n}{frame\PYGZsq{}}\PYG{p}{))} \PYG{n}{+} \PYG{l+m+mi}{8}
\PYG{k+kr}{fun} \PYG{n+nf}{name} \PYG{p}{(\PYGZob{}}\PYG{n}{name}\PYG{p}{,} \PYG{p}{...\PYGZcb{}} \PYG{p}{:} \PYG{n}{frame}\PYG{p}{)} \PYG{p}{=} \PYG{n}{name}
\PYG{k+kr}{fun} \PYG{n+nf}{formals} \PYG{p}{(\PYGZob{}}\PYG{n}{formals}\PYG{p}{,} \PYG{p}{...\PYGZcb{}} \PYG{p}{:} \PYG{n}{frame}\PYG{p}{)} \PYG{p}{=} \PYG{n}{formals}

\PYG{c+cm}{(* To generate label for string *)}
\PYG{k+kr}{fun} \PYG{n+nf}{genString} \PYG{p}{(}\PYG{n}{lab}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)} \PYG{p}{=} \PYG{n+nn}{Symbol}\PYG{p}{.}\PYG{n}{name} \PYG{n}{lab} \PYG{n}{\PYGZca{}} \PYG{l+s+s2}{\PYGZdq{}: .string }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{\PYGZca{}} \PYG{n}{s} \PYG{n}{\PYGZca{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{c+cm}{(* The function Frame.exp is used by Translate to turn a Frame.access into the Tree expression. The Tree.exp argument to Frame.exp is the address of the stack frame that the access lives in. Thus, for an access \PYGZdq{}a\PYGZdq{} such as InFrame(k), we have Frame.exp (a) (TEMP(Frame.FP)) = MEM(BINOP(PLUS, TEMP(Frame.FP), CONST(k))). Why bother to pass the tree expression temp (Frame.FP) as an argument? The answer is that the address of the frame is the same as the current frame pointer only when accessing the variable from its own level. When accessing \PYGZdq{}a\PYGZdq{} from an inner\PYGZhy{}nested function, the frame address must be calculated using static links, and the result of this calculation will be the Tree.exp argument to Frame.exp. If \PYGZdq{}a\PYGZdq{} is a register access such as InReg(t932) then the frame\PYGZhy{}address  argument to Frame.exp will be discarded, and the result will be simply TEMP t932. *)}
\PYG{k+kr}{fun} \PYG{n+nf}{exp} \PYG{n}{frameAccess} \PYG{n}{frameAddress} \PYG{p}{=}
  \PYG{k+kr}{case} \PYG{n}{frameAccess} \PYG{k+kr}{of}
      \PYG{n}{InFrame} \PYG{n}{offset} \PYG{p}{=\PYGZgt{}} \PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{MEM}\PYG{p}{(}\PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{BINOP}\PYG{p}{(}\PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{PLUS}\PYG{p}{,} \PYG{n}{frameAddress}\PYG{p}{,} \PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{CONST} \PYG{n}{offset}\PYG{p}{))}
    \PYG{n}{|} \PYG{n}{InReg} \PYG{n}{temp} \PYG{p}{=\PYGZgt{}} \PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{TEMP}\PYG{p}{(}\PYG{n}{temp}\PYG{p}{)}


\PYG{c+cm}{(* Given the name of the frame and list of variables mentioned in the format of whether they escape or not, function returns the new frame *)}
\PYG{c+cm}{(* Above comment is sufficient but can look at page 142 *)}
\PYG{k+kr}{fun} \PYG{n+nf}{newFrame} \PYG{p}{\PYGZob{}}\PYG{n}{name} \PYG{p}{:} \PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{label}\PYG{p}{,} \PYG{n}{formals} \PYG{p}{:} \PYG{n}{bool} \PYG{n}{list}\PYG{p}{\PYGZcb{}} \PYG{p}{:} \PYG{n}{frame} \PYG{p}{=}
\PYG{k+kr}{let}
  \PYG{k+kr}{fun} \PYG{n+nf}{allocFormals}\PYG{p}{(}\PYG{n}{offset}\PYG{p}{,} \PYG{p}{[],} \PYG{n}{allocList}\PYG{p}{)} \PYG{p}{=} \PYG{n}{allocList}
    \PYG{p}{|} \PYG{n+nf}{allocFormals}\PYG{p}{(}\PYG{n}{offset}\PYG{p}{,} \PYG{n}{curFormal::l}\PYG{p}{,} \PYG{n}{allocList}\PYG{p}{)} \PYG{p}{=}
      \PYG{p}{(}
      \PYG{k+kr}{case} \PYG{n}{curFormal} \PYG{k+kr}{of}
          \PYG{n}{true} \PYG{p}{=\PYGZgt{}} \PYG{n}{allocFormals}\PYG{p}{(}\PYG{n}{offset} \PYG{n}{+} \PYG{n}{wordSize}\PYG{p}{,} \PYG{n}{l}\PYG{p}{,} \PYG{n}{allocList} \PYG{n}{@} \PYG{p}{[}\PYG{n}{InFrame} \PYG{n}{offset}\PYG{p}{])}
        \PYG{n}{|} \PYG{n}{false} \PYG{p}{=\PYGZgt{}} \PYG{n}{allocFormals}\PYG{p}{(}\PYG{n}{offset}\PYG{p}{,} \PYG{n}{l}\PYG{p}{,} \PYG{n}{allocList} \PYG{n}{@} \PYG{p}{[}\PYG{n}{InReg}\PYG{p}{(}\PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{())])}
      \PYG{p}{)}
  \PYG{k+kr}{val} \PYG{n+nv}{aformals} \PYG{p}{=} \PYG{n}{allocFormals} \PYG{p}{(}\PYG{n}{wordSize}\PYG{p}{,} \PYG{n}{formals}\PYG{p}{,} \PYG{p}{[])} \PYG{c+cm}{(* first word is reserved for something *)}
  \PYG{k+kr}{fun} \PYG{n+nf}{viewShift} \PYG{p}{(}\PYG{n}{acc}\PYG{p}{,} \PYG{n}{reg}\PYG{p}{)} \PYG{p}{=} \PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{MOVE}\PYG{p}{(}\PYG{n}{exp} \PYG{n}{acc} \PYG{p}{(}\PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{TEMP} \PYG{n}{fp}\PYG{p}{),} \PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{TEMP} \PYG{n}{reg}\PYG{p}{)}
  \PYG{c+cm}{(* getting the value in argRegs to their correct positions *)}
  \PYG{k+kr}{val} \PYG{n+nv}{shiftInstr} \PYG{p}{=} \PYG{n+nn}{ListPair}\PYG{p}{.}\PYG{n}{map} \PYG{n}{viewShift} \PYG{p}{(}\PYG{n}{aformals}\PYG{p}{,} \PYG{n}{getFirstL} \PYG{p}{(}\PYG{n}{argRegs}\PYG{p}{))}
\PYG{k+kr}{in}
  \PYG{k+kr}{if} \PYG{p}{(}\PYG{n+nn}{List}\PYG{p}{.}\PYG{n}{length} \PYG{n}{formals} \PYG{n}{\PYGZlt{}=} \PYG{n+nn}{List}\PYG{p}{.}\PYG{n}{length} \PYG{n}{argRegs}\PYG{p}{)} \PYG{k+kr}{then}
    \PYG{p}{\PYGZob{}}\PYG{n}{name} \PYG{p}{=} \PYG{n}{name}\PYG{p}{,} \PYG{n}{formals} \PYG{p}{=} \PYG{n}{aformals}\PYG{p}{,} \PYG{n}{numLocals} \PYG{p}{=} \PYG{n}{ref} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{shiftInstr} \PYG{p}{=} \PYG{n}{shiftInstr}\PYG{p}{\PYGZcb{}}
  \PYG{k+kr}{else}
    \PYG{k+kr}{raise} \PYG{n}{ArgExceed} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}No. of arguments exceeded!\PYGZdq{}}\PYG{p}{)}
\PYG{k+kr}{end}

\PYG{c+cm}{(* allocating a variable for our frame *)}
\PYG{k+kr}{fun} \PYG{n+nf}{allocLocal} \PYG{n}{frame\PYGZsq{}} \PYG{n}{escape} \PYG{p}{=} \PYG{p}{(}
  \PYG{k+kr}{case} \PYG{n}{escape} \PYG{k+kr}{of}
      \PYG{n}{true} \PYG{p}{=\PYGZgt{}} \PYG{p}{(}\PYG{n}{incrementNumLocals} \PYG{n}{frame\PYGZsq{}}\PYG{p}{;} \PYG{n}{InFrame}\PYG{p}{(}\PYG{n}{getOffset} \PYG{n}{frame\PYGZsq{}}\PYG{p}{))}
    \PYG{n}{|} \PYG{n}{false} \PYG{p}{=\PYGZgt{}} \PYG{n}{InReg}\PYG{p}{(}\PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{newtemp}\PYG{p}{())}
\PYG{p}{)}


\PYG{c+cm}{(* Calling runtime\PYGZhy{}system functions. To call an external function named initArray with arguments a, b, simply generate a CALL such as CALL(NAME(Temp.namedlabel ( \PYGZdq{}initArray\PYGZdq{} )), [a, b]) This refers to an external function initArray which is written in a language such as C or assembly language \PYGZhy{} it cannot be written in Tiger because Tiger has no mechanism for manipulating raw memory. But on some operating systems, the C compiler puts an underscore at the beginning of each label; and the calling conventions for C functions may differ from those of Tiger functions; and C functions don\PYGZsq{}t expect to receive a static link, and so on. All these target\PYGZhy{}machine\PYGZhy{}specific details should be encapsulated into a function provided by the Frame structure. where externalCall takes the name of the external procedure and the  arguments to be passed. *)}
\PYG{k+kr}{fun} \PYG{n+nf}{externalCall} \PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{args}\PYG{p}{)} \PYG{p}{=} \PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{CALL}\PYG{p}{(}\PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{NAME}\PYG{p}{(}\PYG{n+nn}{T}\PYG{p}{.}\PYG{n}{namedlabel} \PYG{n}{s}\PYG{p}{),} \PYG{n}{args}\PYG{p}{)}

\PYG{c+cm}{(* needed as we are going to add new tree instructions *)}
\PYG{k+kr}{fun} \PYG{n+nf}{seq} \PYG{n}{nil} \PYG{p}{=} \PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{EXP} \PYG{p}{(}\PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{CONST} \PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{p}{|} \PYG{n+nf}{seq} \PYG{p}{[}\PYG{n}{st}\PYG{p}{]} \PYG{p}{=} \PYG{n}{st}
  \PYG{p}{|} \PYG{n+nf}{seq} \PYG{p}{(}\PYG{n}{st} \PYG{n}{::} \PYG{n}{rest}\PYG{p}{)} \PYG{p}{=} \PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{SEQ}\PYG{p}{(}\PYG{n}{st}\PYG{p}{,} \PYG{n}{seq} \PYG{p}{(}\PYG{n}{rest}\PYG{p}{))}

\PYG{c+cm}{(*}
\PYG{c+cm}{  Each Tiger function is translated into a segment of assembly language with a prologue, a body, and an epilogue.}

\PYG{c+cm}{  The body of a Tiger function is an expression, and the body of the translation is simply the translation of that expression.}

\PYG{c+cm}{  The prologue, which precedes the body in the assembly\PYGZhy{}language version of the function, contains:}
\PYG{c+cm}{    1. Pseudo\PYGZhy{}instructions, as needed in the particular assembly language, to}
\PYG{c+cm}{    announce the beginning of a function. (Not relevant in our context)}
\PYG{c+cm}{    2. A label definition for the function name. (Done in procEntryExit3)}
\PYG{c+cm}{    3. An instruction to adjust the stack pointer (to allocate a new frame). (Done in procEntryExit3)}
\PYG{c+cm}{    4. Instructions to save \PYGZdq{}escaping\PYGZdq{} arguments \PYGZhy{} including the static link \PYGZhy{} into the}
\PYG{c+cm}{    frame, and to move nonescaping arguments into fresh temporary registers. (Done in procEntryExit1)}
\PYG{c+cm}{    5. Store instructions to save any callee\PYGZhy{}save registers \PYGZhy{} including the return}
\PYG{c+cm}{    address register \PYGZhy{} used within the function. (Done in procEntryExit1)}

\PYG{c+cm}{  (6) The function body.}

\PYG{c+cm}{  The epilogue comes after the body and contains}
\PYG{c+cm}{    7. An instruction to move the return value (result of the function) to the register reserved for that purpose. (Already added in body by translate)}
\PYG{c+cm}{    8. Load instructions to restore the callee\PYGZhy{}save registers. (Done in procEntryExit1)}
\PYG{c+cm}{    9. An instruction to reset the stack pointer (to deallocate the frame). (Done in procEntryExit3)}
\PYG{c+cm}{    10. A return instruction (JUMP to the return address). (Done in procEntryExit3)}
\PYG{c+cm}{    11. pseudo\PYGZhy{}instructions, as needed, to announce the end of a function. (Not relevant in our context)}

\PYG{c+cm}{  Some of these items (1, 3, 9 and 11) depend on exact knowledge of the frame size, which will not be known until after the register allocator determines how many local variables need to be kept in the frame because they don\PYGZsq{}t fit in registers. So these instructions should be generated very late, in a frame function called procEntryExit3.}
\PYG{c+cm}{*)}

\PYG{c+cm}{(* As mentioned in the above comment, it does what is known as \PYGZdq{}view shift\PYGZdq{} *)}
\PYG{k+kr}{fun} \PYG{n+nf}{procEntryExit1}\PYG{p}{(}\PYG{n}{frame\PYGZsq{}} \PYG{k+kr}{as} \PYG{p}{\PYGZob{}}\PYG{n}{shiftInstr}\PYG{p}{,} \PYG{p}{...\PYGZcb{}} \PYG{p}{:} \PYG{n}{frame}\PYG{p}{,} \PYG{n}{body}\PYG{p}{)} \PYG{p}{=}
\PYG{k+kr}{let}
  \PYG{k+kr}{val} \PYG{n+nv}{pairs} \PYG{p}{=} \PYG{n}{map} \PYG{p}{(}\PYG{k+kr}{fn} \PYG{n}{reg} \PYG{p}{=\PYGZgt{}} \PYG{p}{(}\PYG{n}{allocLocal} \PYG{n}{frame\PYGZsq{}} \PYG{n}{false}\PYG{p}{,} \PYG{n}{reg}\PYG{p}{))} \PYG{p}{([}\PYG{n}{ra}\PYG{p}{]} \PYG{n}{@} \PYG{n}{getFirstL} \PYG{p}{(}\PYG{n}{savedRegs}\PYG{p}{))}
  \PYG{k+kr}{val} \PYG{n+nv}{saves} \PYG{p}{=} \PYG{n}{map} \PYG{p}{(}\PYG{k+kr}{fn} \PYG{p}{(}\PYG{n}{allocLoc}\PYG{p}{,} \PYG{n}{reg}\PYG{p}{)} \PYG{p}{=\PYGZgt{}} \PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{MOVE} \PYG{p}{(}\PYG{n}{exp} \PYG{n}{allocLoc} \PYG{p}{(}\PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{TEMP} \PYG{n}{fp}\PYG{p}{),} \PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{TEMP} \PYG{n}{reg}\PYG{p}{))} \PYG{n}{pairs}
  \PYG{k+kr}{val} \PYG{n+nv}{restores} \PYG{p}{=} \PYG{n}{map} \PYG{p}{(}\PYG{k+kr}{fn} \PYG{p}{(}\PYG{n}{allocLoc}\PYG{p}{,} \PYG{n}{reg}\PYG{p}{)} \PYG{p}{=\PYGZgt{}} \PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{MOVE} \PYG{p}{(}\PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{TEMP} \PYG{n}{reg}\PYG{p}{,} \PYG{n}{exp} \PYG{n}{allocLoc} \PYG{p}{(}\PYG{n+nn}{Tr}\PYG{p}{.}\PYG{n}{TEMP} \PYG{n}{fp}\PYG{p}{)))} \PYG{p}{(}\PYG{n+nn}{List}\PYG{p}{.}\PYG{n}{rev} \PYG{n}{pairs}\PYG{p}{)}
\PYG{k+kr}{in}
  \PYG{n}{seq}\PYG{p}{(}\PYG{n}{shiftInstr} \PYG{n}{@} \PYG{n}{saves} \PYG{n}{@} \PYG{p}{[}\PYG{n}{body}\PYG{p}{]} \PYG{n}{@} \PYG{n}{restores}\PYG{p}{)}
\PYG{k+kr}{end}


\PYG{c+cm}{(* This function appends a \PYGZdq{}sink\PYGZdq{} instruction to the function body to tell the register allocator that certain registers are live at procedure exit. Having zero live at the end means that it is live throughout, which will prevent the register allocator from trying to use it for some other purpose. The same trick works for any other special registers the machine might have. *)}
\PYG{c+cm}{(* The following snippet was given in book, just modified src. *)}
\PYG{k+kr}{fun} \PYG{n+nf}{procEntryExit2}\PYG{p}{(}\PYG{n}{frame}\PYG{p}{,} \PYG{n}{body}\PYG{p}{)} \PYG{p}{=}
        \PYG{n}{body} \PYG{n}{@}
        \PYG{p}{[}\PYG{n+nn}{Assem}\PYG{p}{.}\PYG{n}{OPER} \PYG{p}{\PYGZob{}}\PYG{n}{assem} \PYG{p}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}\PYG{p}{,}
                  \PYG{n}{src} \PYG{p}{=} \PYG{n}{getFirstL} \PYG{p}{(}\PYG{n}{specialregs} \PYG{n}{@} \PYG{n}{savedRegs}\PYG{p}{),}
                  \PYG{n}{dst} \PYG{p}{=} \PYG{p}{[],} \PYG{n}{jump} \PYG{p}{=} \PYG{n}{SOME}\PYG{p}{[]\PYGZcb{}}
        \PYG{p}{]}

\PYG{k+kr}{fun} \PYG{n+nf}{procEntryExit3}\PYG{p}{(}\PYG{n}{frame\PYGZsq{}} \PYG{p}{:} \PYG{n}{frame}\PYG{p}{,} \PYG{n}{body}\PYG{p}{)} \PYG{p}{=}
  \PYG{p}{\PYGZob{}}\PYG{n}{prolog} \PYG{p}{=} \PYG{n+nn}{Symbol}\PYG{p}{.}\PYG{n}{name} \PYG{p}{(}\PYG{n}{name} \PYG{n}{frame\PYGZsq{}}\PYG{p}{)} \PYG{n}{\PYGZca{}} \PYG{l+s+s2}{\PYGZdq{}:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{\PYGZca{}}
    \PYG{c+cm}{(* fp \PYGZhy{}\PYGZgt{} 0(sp) *)}
    \PYG{l+s+s2}{\PYGZdq{}sw fp 0(sp)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{\PYGZca{}}
    \PYG{c+cm}{(* sp \PYGZhy{}\PYGZgt{} fp *)}
    \PYG{l+s+s2}{\PYGZdq{}move fp sp}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{\PYGZca{}}
    \PYG{c+cm}{(* sp = sp \PYGZhy{}  (allocating space in stack) *)}
    \PYG{l+s+s2}{\PYGZdq{}addiu sp sp \PYGZhy{}\PYGZdq{}} \PYG{n}{\PYGZca{}} \PYG{n+nn}{Int}\PYG{p}{.}\PYG{n}{toString} \PYG{p}{(}\PYG{n}{getFOffset} \PYG{p}{(}\PYG{n}{frame\PYGZsq{}}\PYG{p}{))} \PYG{n}{\PYGZca{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{body} \PYG{p}{=} \PYG{n}{body}\PYG{p}{,}
            \PYG{c+cm}{(* fp \PYGZhy{}\PYGZgt{} sp *)}
    \PYG{n}{epilog} \PYG{p}{=} \PYG{l+s+s2}{\PYGZdq{}move sp fp}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{\PYGZca{}}
    \PYG{c+cm}{(* lw Rdest, address			Load Word}
\PYG{c+cm}{Load the 32\PYGZhy{}bit quantity (word) at address into register Rdest. *)}
    \PYG{l+s+s2}{\PYGZdq{}lw fp 0(sp)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{\PYGZca{}}
    \PYG{c+cm}{(* jr Rsource				Jump Register}
\PYG{c+cm}{Unconditionally jump to the instruction whose address is in register Rsource.*)}
    \PYG{l+s+s2}{\PYGZdq{}jr ra}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{end}
\end{Verbatim}
